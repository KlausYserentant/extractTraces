function uiTwoColors()
% create and open the main two color (two emission channels) analysis ui
    
    fig = figure( ...
        'Units', 'pixel', ...
        'Position', [0, 0, 1000, 750], ...
        'Name', 'Trace Selection', ...
        'MenuBar', 'none', ...
        'Toolbar', 'none', ...
        'Color', get(0, 'defaultuicontrolbackgroundcolor'), ...
        'NumberTitle', 'off', ...
        'Resize', 'on', ...
        'Visible', 'off');
    
    % save all gui object handles as guidata so they can be accessed later
    handles = guidata(fig);
    
    % slice the display up into separate panels to organize the controls
    panelPhotonStreams = uipanel( ...
        'Parent', fig, ...
        'Units', 'normalized', ...
        'Position', [.01, .49, .79, .50], ...
        'Title', 'Photon Streams');
    panelMenu = uipanel( ...
        'Parent', fig, ...
        'Units', 'normalized', ...
        'Position', [.81, .49, .18, .50], ...
        'Title', 'Menu');
    panelTrace = uipanel( ...
        'Parent', fig, ...
        'Units', 'normalized', ...
        'Position', [.01, .01, .60, .47], ...
        'Title', 'Trace');
    panelTraces = uipanel( ...
        'Parent', fig, ...
        'Units', 'normalized', ...
        'Position', [.62, .01, .18, .47], ...
        'Title', 'Trace Selection');
    panelSettings = uipanel( ...
        'Parent', fig, ...
        'Units', 'normalized', ...
        'Position', [.81, .01, .18, .47], ...
        'Title', 'Calibration and Settings');
    
    % panelPhotonStreams: axes for all four photon streams
    handles.photonStreams = cell(2, 1);
    handles.photonStreams{1} = axes( ...
        'Parent', panelPhotonStreams, ...
        'Units', 'normalized', ...
        'PlotBoxAspectRatio',[1,1,1], ... %Equal axis length
        'OuterPosition', [.0, .0, .47, 1.0], ... % [
        'HandleVisibility', 'callback', ...
        'NextPlot', 'replacechildren');
    handles.photonStreams{2} = axes( ...
        'Parent', panelPhotonStreams, ...
        'Units', 'normalized', ...
        'PlotBoxAspectRatio',[1,1,1], ... %Equal axis length
        'OuterPosition', [.5, .0, .47, 1.0], ... % [0.25, .0, .25, 1.0] for split frame
        'HandleVisibility', 'callback', ...
        'NextPlot', 'replacechildren');

    
    % panelMenu: buttons for all accessible actions
    uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'text', ...
        'Units', 'normalized', ...
        'Position', [.05, .9, .9, .1], ...
        'String', 'Data file format', ...
        'BusyAction', 'cancel');
     handles.dataFormat = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'popupmenu', ...
        'Units', 'normalized', ...
        'Position', [.05, .85, .9, .1], ...
        'String', strvcat('Full frame, ALEX','Split frame'), ... % TODO: add 'Full frame, 2 files'
        'Callback', @dataformatCallback, ...
        'Value', 1, ...
        'BusyAction', 'cancel', ...
        'Enable', 'on');
    uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'pushbutton', ...
        'Units', 'normalized', ...
        'Position', [.05, .75, .9, .1], ...
        'String', 'New Calibration', ...
        'Callback', @newCalibrationCallback, ...
        'BusyAction', 'cancel');
    uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'pushbutton', ...
        'Units', 'normalized', ...
        'Position', [.05, .65, .9, .1], ...
        'String', 'Load Calibration', ...
        'Callback', @loadCalibrationCallback, ...
        'BusyAction', 'cancel');
    handles.openMovie = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'pushbutton', ...
        'Units', 'normalized', ...
        'Position', [.05, .55, .9, .1], ...
        'String', 'Open Movie', ...
        'Callback', @openMovieCallback, ...
        'BusyAction', 'cancel');
    
    uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'text', ...
        'Units', 'normalized', ...
        'Position', [.05, .42, .9, .1], ...
        'String', 'Photon Streams Frame', ...
        'BusyAction', 'cancel');
    handles.photonStreamsStart = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'edit', ...
        'Units', 'normalized', ...
        'Position', [.05, .34, .2, .13], ...
        'String', '1', ...
        'BusyAction', 'cancel', ...
        'Callback', @updateSumPhotonStreams, ...
        'Enable', 'off');
    handles.photonStreamsEnd = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'edit', ...
        'Units', 'normalized', ...
        'Position', [.29, .34, .2, .13], ...
        'String', '10', ...
        'Callback', @updateSumPhotonStreams, ...
        'BusyAction', 'cancel', ...
        'Enable', 'off');    
    handles.photonStreamsMethod = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'popupmenu', ...
        'Units', 'normalized', ...
        'Position', [.53, .41, .42, .06], ...
        'String', strvcat('sum', 'max projection'), ...
        'Value', 1, ...
        'Callback', @updateSumPhotonStreams, ...
        'BusyAction', 'cancel', ...
        'Enable', 'off');
    handles.photonStreamsNormalization = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'popupmenu', ...
        'Units', 'normalized', ...
        'Position', [.53, .34, .42, .06], ...
        'String', strvcat('relative', 'absolute'), ...
        'Value', 1, ...
        'Callback', @updateSumPhotonStreams, ...
        'BusyAction', 'cancel', ...
        'Enable', 'off');   
    handles.extractTraces = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'pushbutton', ...
        'Units', 'normalized', ...
        'Position', [.05, .22, .9, .1], ...
        'String', 'Extract Traces', ...
        'Callback', @extractTracesCallback, ...
        'BusyAction', 'cancel', ...
        'Enable', 'off');
    handles.handpickTraces = uicontrol( ...
        'Parent' , panelMenu, ...
        'Style','pushbutton', ...
        'Units', 'normalized', ...
        'Position', [.05, .12, .9, .1], ...
        'String', 'Handpick Additional Traces', ...
        'Callback', @handpickTracesCallback, ...
        'BusyAction', 'cancel', ...
        'Enable', 'off');
    handles.exportTraces = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'pushbutton', ...
        'Units', 'normalized', ...
        'Position', [.05, .02, .9, .1], ...
        'String', 'Export Traces', ...
        'Callback', @exportTracesCallback, ...
        'BusyAction', 'cancel', ...
        'Enable', 'off');
%     handles.calculateCorrections = uicontrol( ...
%         'Parent', panelMenu, ...
%         'Style', 'pushbutton', ...
%         'Units', 'normalized', ...
%         'Position', [.05, .12, .9, .1], ...
%         'String', 'Calculate Corrections', ...
%         'Callback', @calculateCorrectionsCallback, ...
%         'BusyAction','cancel', ...
%         'Enable', 'off');
%     handles.fretAnalysis = uicontrol( ...
%         'Parent', panelMenu, ...
%         'Style', 'pushbutton', ...
%         'Units', 'normalized', ...
%         'Position', [.05, .02, .9, .1], ...
%         'String', 'Fret Analysis', ...
%         'Callback', @fretAnalysisCallback, ...
%         'BusyAction', 'cancel', ...
%         'Enable', 'off');
    
    % panelTrace: axes for the selected trace
    handles.trace1 = axes( ...
        'Parent', panelTrace, ...
        'Units', 'normalized', ...
        'OuterPosition', [.0, .5, .75, .5], ...
        'HandleVisibility', 'callback', ...
        'NextPlot', 'replacechildren');
    handles.traceHist1 = axes( ...
        'Parent', panelTrace, ...
        'Units', 'normalized', ...
        'OuterPosition', [.75, .5, .25, .5], ...
        'HandleVisibility', 'callback', ...
        'NextPlot', 'replacechildren');
    handles.trace2 = axes( ...
        'Parent', panelTrace, ...
        'Units', 'normalized', ...
        'OuterPosition', [.0, .0, .75, .5], ...
        'HandleVisibility', 'callback', ...
        'NextPlot', 'replacechildren'); 
    handles.traceHist2 = axes( ...
        'Parent', panelTrace, ...
        'Units', 'normalized', ...
        'OuterPosition', [.75, .0, .25, .5], ...
        'HandleVisibility', 'callback', ...
        'NextPlot', 'replacechildren');
    
    % panelTraces: list of available traces with checkboxes for export
    handles.selectAllTraces = uicontrol( ...
        'Style', 'checkbox',...
        'Parent', panelTraces, ...
        'Units','normalized',...
        'Position', [.02, .95, .96, .04], ... 
        'String', 'Select All', ...
        'Callback', @SelectAllTraces, ...
        'Value', 1, ...
        'Enable', 'off');
    handles.traces = uitable( ...
        'Parent', panelTraces, ...
        'Units','normalized',...
        'Position', [.02, .01, .96, .93], ...
        'CellSelectionCallback', @tracesCallback, ...
        'ColumnFormat', {'logical','char'} ,...
        'ColumnEditable', [true,false],...
        'ColumnWidth', {15 141}, ...
        'ColumnName', [], ...
        'RowName', [], ...
        'Data', '' );
    
    % panelSettings: controls for calibration and alignment settings
    uicontrol( ...
        'Parent', panelSettings, ...
        'Style','text', ...
        'Units', 'normalized', ...
        'Position', [.02, .92, .96, .06], ...
        'String', 'Calibration File Path', ...
        'HorizontalAlignment', 'left');
    handles.calibrationFilePath = uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'edit', ...
        'Units', 'normalized', ...
        'Position', [.02, .86, .96, .06], ...
        'String', '', ...
        'UserData', '', ...
        'Callback', @calibrationFilePathCallback, ...
        'BusyAction', 'queue');
    uicontrol( ...
        'Parent', panelSettings, ...
        'Style','text', ...
        'Units', 'normalized', ...
        'Position', [.02, .78, .96, .06], ...
        'String', 'Slit Orientation', ...
        'HorizontalAlignment', 'left');
    handles.slitOrientation = uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'popupmenu', ...
        'Units', 'normalized', ...
        'Position', [.02, .72, .96, .07], ...
        'String', strvcat('horizontal', 'vertical','full frame'), ...
        'Value', 1, ...
        'Callback', @slitOrientationCallback, ...
        'BusyAction', 'cancel');
%     uicontrol('Parent', panelSettings, ...
%         'Style','text', ...
%         'Units', 'normalized', ...
%         'Position', [.02, .64, .96, .06], ...
%         'String', 'Excitation Odd Images', ...
%         'HorizontalAlignment', 'left');
%     handles.excitationOdd = uicontrol( ...
%         'Parent', panelSettings, ...
%         'Style', 'popupmenu', ...
%         'Units', 'normalized', ...
%         'Position', [.02, .58, .96, .06], ...
%         'String', strvcat('donor', 'acceptor'), ...
%         'Value', 1, ...
%         'Callback', @excitationOddCallback, ...
%         'BusyAction', 'cancel');
    uicontrol('Parent', panelSettings, ...
        'Style','text', ...
        'Units', 'normalized', ...
        'Position', [.02, .50, .96, .06], ...
        'String', 'Detection Left Channel', ...
        'HorizontalAlignment', 'left');
    handles.detectionLeft = uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'popupmenu', ...
        'Units', 'normalized', ...
        'Position', [.02, .44, .96, .06], ...
        'String', strvcat('donor', 'acceptor'), ...
        'Value', 2, ...
        'Callback', @detectionLeftCallback, ...
        'BusyAction', 'cancel');
    uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'text', ...
        'String', 'Peak Radius', ...
        'Units', 'normalized', ...
        'Position', [.02, .36, .96, .06], ...
        'HorizontalAlignment', 'left');
    handles.peakRadius = uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'edit', ...
        'Units', 'normalized', ...
        'Position', [.02, .30, .96, .07], ...
        'String', num2str(3), ...
        'Callback', @peakRadiusCallback, ...
        'BusyAction', 'cancel');
    uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'text', ...
        'String', 'Trace Acquisition Method', ...
        'Units', 'normalized', ...
        'Position', [.02, .22, .96, .06], ...
        'HorizontalAlignment', 'left');
    handles.traceAcquisitionMethod = uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'popupmenu', ...
        'Units', 'normalized', ...
        'Position', [.02, .16, .96, .06], ...
        'String', strvcat('max', 'pixel', 'sum'), ...
        'Value', 3, ...
        'Callback', @traceAcquisitionMethodCallback, ...
        'BusyAction', 'cancel');
    uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'text', ...
        'String', 'Display Colormap', ...
        'Units','normalized', ...
        'Position', [.02, .08, .96, .06], ...
        'HorizontalAlignment', 'left');
    handles.colormap = uicontrol(...
        'Parent', panelSettings, ...
        'Style', 'popupmenu', ...
        'Units', 'normalized', ...
        'Position', [.02, .02, .96, .06], ...
        'String', strvcat('gray', 'hot', 'hsv', 'jet'), ...
        'Value', 2, ...
        'Callback', @colormapCallback, ...
        'BusyAction', 'cancel');
    
    % setting visibility to "on" only now speeds up the window creation
    set(fig, 'Visible', 'on');
    guidata(fig, handles);
    
    % use guidata only for handles related to the actual user interface
    % use appdata to store the actual data
    
    % use default values from the ui
    so = ui.readPopupmenu(handles.slitOrientation);
    dl = ui.readPopupmenu(handles.detectionLeft);
    df = ui.readPopupmenu(handles.dataFormat);
    % calibration for alex data w/o any transformations
    switch df
        case 'Split frame'
            setappdata(fig, 'calibration', alex.movie.Calibration(1, 2, so, df));
        case 'Full frame, ALEX'
            setappdata(fig, 'calibration', alex.movie.Calibration(2, 1, so, df));
    end
    % default mapping between stream indices and names
    setappdata(fig, 'mapping', alex.movie.MappingTwoColors(dl));
    % store empty placeholder variables for movie and list of traces
    setappdata(fig, 'movie', []);
    setappdata(fig, 'peaks', []);
    setappdata(fig, 'traces', []);
end

% -----------------------------------------------------------------------------
% file format callbacks
function dataformatCallback(hObject, eventdata)
    handles = guidata(gcbf);
    dataformat = ui.readPopupmenu(hObject);
    so = ui.readPopupmenu(handles.slitOrientation);
    
    switch dataformat
        case 'Full frame, ALEX'
            set(handles.slitOrientation, 'Enable', 'off');
            set(handles.slitOrientation, 'String', 'full frame');
            setappdata(hObject, 'calibration', alex.movie.Calibration(1, 2, so, dataformat));
        case 'Split frame'
            set(handles.slitOrientation, 'Enable', 'on');
            setappdata(hObject, 'calibration', alex.movie.Calibration(2, 1, so, dataformat));
    end
end

 
% -----------------------------------------------------------------------------
% calibration callbacks

function newCalibrationCallback(hObject, eventdata)
% call uiCalibration to create a new calibration file and load it

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%% !! To implement: for dataformat = Full frame, 2 files, 2
%%%%%%%%%%%%% separate files have to be read for calibration.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        [filePath, slitOrientation] = uiCalibration();

    
    % create a calibration object from the newly created transformation file
    % and the current ui settings
    if not(isempty(filePath))
        handles = guidata(hObject);
        
        if strcmpi(slitOrientation, 'horizontal')
            set(handles.slitOrientation, 'Value', 1);
        elseif strcmpi(slitOrientation, 'vertical')
            set(handles.slitOrientation, 'Value', 2);
        elseif strcmpi(slitOrientation, 'full frame')
            set(handles.slitOrientation, 'Value', 3);
        end
        
        calibration = getappdata(gcbf, 'calibration');
        calibration.slitOrientation = slitOrientation;
        calibration.updateTransformationFromFile(filePath);
        calibration.dataFormat = ui.readPopupmenu(handles.dataFormat);
        set(handles.calibrationFilePath, 'String', calibration.filePath);
    end
end

function loadCalibrationCallback(hObject, eventdata)
% select a calibration file and load it
    
    filePath = ui.dialogOpenFile('.mat', 'Select a Calibration File');
    
    if not(isempty(filePath))
        handles = guidata(hObject);
        
        calibration = getappdata(gcbf, 'calibration');
        calibration.updateTransformationFromFile(filePath);
        set(handles.calibrationFilePath, 'String', calibration.filePath);
    end
end

function calibrationFilePathCallback(hObject, eventdata)
% restore the original value
%
% calibrationFile textedit must be enabled so that the whole path can be
% selected, but it should not be changed;
    
    calibration = getappdata(gcbf, 'calibration');
    set(hObject, 'String', calibration.filePath);
end

function slitOrientationCallback(hObject, eventdata)
% change slit orientation in the calibration
    
    calibration = getappdata(gcbf, 'calibration');
    calibration.slitOrientation = ui.readPopupmenu(hObject);
    
    movie = getappdata(gcbf, 'movie');
    if not(isempty(movie))
        movie.summarizePhotonStreams(1, 10, 'sum');
        
        updatePhotonStreams();
        warning('changing the slit orientation does not affect traces')
    end
end

function detectionLeftCallback(hObject, eventdata)
% change the detection color alignment in the mapping and replot
    
    mapping = getappdata(gcbf, 'mapping');
    mapping.detectionLeft = ui.readPopupmenu(hObject);
    
    updatePhotonStreams();
    updateTrace();
end

% -----------------------------------------------------------------------------
% movie callbacks

function openMovieCallback(hObject, eventdata)
% select a movie file and create the corresponding movie object

    [path_, filterIndex] = ui.dialogOpenFile({'*.tif';'*.sif'}, 'Select a Movie File');
    
    if not(isempty(path_))
        % allow different raw data formats, e.g. sif and tif
        if filterIndex == 2
            raw = alex.movie.SifFile(path_);
        elseif filterIndex == 1
            raw = alex.movie.TifFile(path_);
        end
        
        movie = alex.movie.Movie(raw, getappdata(gcbf, 'calibration'));
        
        setappdata(gcbf, 'movie', movie);
        setappdata(gcbf, 'peaks', []);
        setappdata(gcbf, 'traces', []);
        
        handles = guidata(hObject);
        % update figure title
        set(gcbf, 'Name', ['Trace Selection (' movie.filePath ')']);
        % enable the newly accessible actions
        set(handles.photonStreamsStart, 'Enable', 'on');
        set(handles.photonStreamsEnd, 'Enable', 'on');
        set(handles.photonStreamsMethod, 'Enable', 'on');
        set(handles.photonStreamsNormalization, 'Enable', 'on');
        set(handles.extractTraces, 'Enable', 'on');
        set(handles.handpickTraces, 'Enable', 'on');
        % the following actions need extracted traces (not available now)
        set(handles.exportTraces, 'Enable', 'off');
%         set(handles.calculateCorrections, 'Enable', 'off');
%         set(handles.fretAnalysis, 'Enable', 'off');
        
        updatePhotonStreams();
        updateTraces();
        updateTrace();
    end
end

% -----------------------------------------------------------------------------
% peaks and traces callbacks

function extractTracesCallback(hObject, eventdata)
% select thresholds for the peak finder, run it and update the traces
    
    movie = getappdata(gcbf, 'movie');
    mapping = getappdata(gcbf, 'mapping');
    handles = guidata(hObject);
    
    uiThresholds(movie, mapping);
    movie.peakRadius = str2num(get(handles.peakRadius, 'String'));
    movie.traceAquisitionMethod = ui.readPopupmenu(handles.traceAcquisitionMethod);
    
    peaks = alex.movie.findPeaks(movie);
    setappdata(gcbf, 'peaks', peaks);
    updatePhotonStreams();
    
    traces = alex.traces.extract(movie, mapping, peaks);
    setappdata(gcbf, 'traces', traces);
    updateTraces();
    updateTrace();
    
    % enable the actions that are now accessible with existing traces
    % TODO only enable if there are some resulting traces
    set(handles.exportTraces, 'Enable', 'on');
    set(handles.selectAllTraces, 'Enable', 'on');
%     set(handles.calculateCorrections, 'Enable', 'on');
%     set(handles.fretAnalysis, 'Enable', 'on');
end

function handpickTracesCallback(hObject, eventdata)
% select points in the axes by left mouseclick,
% end selection by pressing the return button
    
    movie = getappdata(gcbf, 'movie');
    mapping = getappdata(gcbf, 'mapping');
    peaks = getappdata(gcbf, 'peaks');
    peaksPhotonStream = getappdata(gcbf, 'peaksInPhotonStream');
    handles = guidata(hObject);
    
    movie.peakRadius = str2num(get(handles.peakRadius, 'String'));
    movie.traceAquisitionMethod = ui.readPopupmenu(handles.traceAcquisitionMethod);
    
    
    [peaks, peaksPhotonStream] = alex.movie.handpickPeaks(movie, mapping, peaks, peaksPhotonStream, handles);
    setappdata(gcbf, 'peaks', peaks);
    setappdata(gcbf, 'peaksPhotonStream', peaksPhotonStream);
    updatePhotonStreams();

    traces = alex.traces.extract(movie, mapping, peaks);
    setappdata(gcbf, 'traces', traces);
    updateTraces();
    updateTrace();
    
    % enable the actions that are now accessible with existing traces
    % TODO only enable if there are some resulting traces
    set(handles.exportTraces, 'Enable', 'on');
    set(handles.selectAllTraces, 'Enable', 'on');
%     set(handles.calculateCorrections, 'Enable', 'on');
%     set(handles.fretAnalysis, 'Enable', 'on');
end

function exportTracesCallback(hObject, eventdata)
% select a file name and export the currently selected traces to it
    
    handles = guidata(hObject);
    selected = find(cell2mat(handles.traces.Data(:,1)));
    
    movie = getappdata(gcbf, 'movie');
    mapping = getappdata(gcbf, 'mapping');
    traces = getappdata(gcbf, 'traces');
    
    % you can choose between .csv and .txt export
    % not sure wether the internal structure of the file is differentt
    % suggest an export file based on the movie file path
    exportFileSuggestion = strcat(movie.filePath(1:end-4));
    [fileName, pathName, filterIndex] = ...
        uiputfile({'.csv'; '.txt'}, 'Select an Export File', exportFileSuggestion);
    
    if not(fileName == 0) % user canceled operation
        file_ = fullfile(pathName, fileName);
        % allow different export data formats, e.g. csv and sif
        if filterIndex == 1
            % STANDARD Csv EXPORT WITH FULL INFORMATION
            alex.exportCsvTwoColors(file_, movie, mapping, traces(selected));
        elseif filterIndex == 2
            % STANDARD Txt EXPORT WITH FULL INFORMATION, header exported as
            % csv
            alex.exportCsvTxtTwoColors(file_, movie, mapping, traces(selected));
        end
    end
end

function tracesCallback(hObject, callbackdata)
% update the trace plot to show the newly selected trace
    
    updateTrace(hObject, callbackdata);
end

function peakRadiusCallback(hObject, eventdata)
% recalculate the traces with the new peak radius
    
    movie = getappdata(gcbf, 'movie');
    movie.peakRadius = str2num(get(hObject, 'String'));
    
    traces = alex.traces.extract(movie, getappdata(gcbf, 'peaks'));
    setappdata(gcbf, 'traces', traces);
    
    updatePhotonStreams();
    updateTraces();
    updateTrace();
end

function traceAcquisitionMethodCallback(hObject, eventdata)
% recalculate traces with the new aquisition method
    
    movie = getappdata(gcbf, 'movie');
    mapping = getappdata(gcbf, 'mapping');
    movie.traceAquisitionMethod = ui.readPopupmenu(hObject);
    
    traces = alex.traces.extract(movie, mapping, getappdata(gcbf, 'peaks'));
    setappdata(gcbf, 'traces', traces);
    
    updatePhotonStreams();
    updateTraces();
    updateTrace();
end

% -----------------------------------------------------------------------------
% further analysis callbacks

% function calculateCorrectionsCallback(hObject, eventdata)
% % call calculate correction factors with the currently selected traces
%     handles = guidata(hObject);
%     selected = get(handles.traces, 'Value');
%     
%     movie = getappdata(gcbf, 'movie');
%     traces = getappdata(gcbf, 'traces');
%     
%     % NO EXTRA FILTER
%     uiCalculateCorrections(movie, traces(selected));
% end

% function fretAnalysisCallback(hObject, eventdata)
% % call fret analysis with the currently selected traces
%     
%     handles = guidata(hObject);
%     selected = get(handles.traces, 'Value');
%     
%     movie = getappdata(gcbf, 'movie');
%     mapping = getappdata(gcbf, 'mapping');
%     traces = getappdata(gcbf, 'traces');
%     
%     % uncomment the wanted filter
%     % WARNING need to comment/uncomment the corresponding section in the export
%     % function
%     
%     % FILTER FOR TF DETECTION (remove red only traces)
%     selectedTraces = alex.traces.filterTf(traces(selected));
%     % BLEACHING DETECTION
%     %selectedTraces = traces(selected);
%     selectedFrames = alex.traces.detectBleachingOutliersTf(selectedTraces);
%     uiFretAnalysis(movie, mapping, selectedTraces, selectedFrames);
%     % NO EXTRA FILTER
%      % uiFretAnalysis(movie, traces);
%     % FOR JESSICA (select only the first two frames)
% %     selectedTraces = traces(selected);
% %     selectedFrames = cell(length(selectedTraces), 1);
% %     for i = 1:length(selectedFrames)
% %         selectedFrames{i} = 1:1;
% %     end
% %     uiFretAnalysis(movie, selectedTraces, selectedFrames);
% end

% -----------------------------------------------------------------------------
% misc callbacks

function updateSumPhotonStreams(hObject, eventdata)
% replot the photon streams with the new start and end frame
    handles = guidata(gcbf);
    movie = getappdata(gcbf, 'movie');
       
    % recover the start and end frame from the gui
    startFrame = str2num(get(handles.photonStreamsStart, 'String'));
    endFrame = str2num(get(handles.photonStreamsEnd, 'String'));
    
    % check if start/end frames are valid for loaded movie.
    if startFrame>movie.frameCount
        errordlg('Start frame is invalid. Will use "1" instead.')
        startFrame = 1;
    end
    
    if endFrame>movie.frameCount
        errordlg('End frame is invalid. Will use end of stack insted.')
        endFrame = movie.frameCount;
    end
    
    % recover wether sum or max projection should be used for photon stream
    % image
    method = ui.readPopupmenu(handles.photonStreamsMethod);
    normalization = ui.readPopupmenu(handles.photonStreamsNormalization);
    movie.summarizePhotonStreams(startFrame, endFrame - startFrame + 1, method, normalization);
    updatePhotonStreams();
end

function colormapCallback(hObject, eventdata)
% replot the photon streams with the new colormap
    
    updatePhotonStreams();
end

% -----------------------------------------------------------------------------
% update plotted data

function updatePhotonStreams()
% plot the photon stream sum images
    
    movie = getappdata(gcbf, 'movie');
    mapping = getappdata(gcbf, 'mapping');
    peaks = getappdata(gcbf, 'peaks');
    
    handles = guidata(gcbf);
    cm = ui.readPopupmenu(handles.colormap);
    axs = handles.photonStreams;
    
    % plot the photon streams
    images = alex.movie.createPhotonStreamImages(movie, peaks, cm);
    for i = 1:length(images)
        namePhotonStream = mapping.names{i};
        
        axes(axs{i});
        hold off;
        image(images{mapping.getIndex(namePhotonStream)});
        title(namePhotonStream);
        grid on;
        hold on;
    end
end

function updateTraces(hObject, eventdata)
% update the list of traces
    
    traces = getappdata(gcbf, 'traces');
    
    handles = guidata(gcbf);
    
    if not(isempty(traces))
        % remove old selection and update traces
        % set(handles.traces, 'Value', [1])
        Check = num2cell(true(1,length(traces)));
        Data = [Check;{traces.name}];
        set(handles.traces, 'Data', Data');
    else
        set(handles.traces, 'Data', '');
    end
end

function updateTrace(varargin)
% display the currently selected trace (if any exists)
    
    traces = getappdata(gcbf, 'traces');
    if nargin == 0; return; end
    if isempty(varargin{2}.Indices); return; end
    
    handles = guidata(gcbf);
    % listbox allows multiple selection; plot the first trace in selection
    indices = varargin{2}.Indices;
    t = traces(indices(1));
    
    ui.plotTraceIntensitiesTwoColor(t, handles.trace1, handles.trace2);
    
    axes(handles.traceHist1);
    % create histogram of intensity channel and background channel
    photonCountsRedEm = t.rawByName('Aem');
    [n, xout] = hist(photonCountsRedEm, 30);
    barh(xout, n, 'FaceColor', [1,0,0], 'EdgeColor', [1,0,0]);
    hold on;
    photonCountsRedEmBkg = t.backgroundByName('Aem');
    [n, xout] = hist(photonCountsRedEmBkg, 30);
    barh(xout, n, 'FaceColor', [0.5,0,0], 'EdgeColor', [0.5,0,0]);
    hold off;
    set(gca, 'YLim',  get(handles.trace1, 'YLim'));
    
    axes(handles.traceHist2);
    % create histogram of intensity channel and background channel
    photonCountsGreenEm = t.rawByName('Dem');
    [n, xout] = hist(photonCountsGreenEm, 30);
    barh(xout, n, 'FaceColor', [0,1,0], 'EdgeColor', [0,1,0]);
    hold on;
    photonCountsGreenEmBkg = t.backgroundByName('Dem');
    [n, xout] = hist(photonCountsGreenEmBkg, 30);
    barh(xout, n, 'FaceColor', [0,0.5,0], 'EdgeColor', [0,0.5,0]);
    hold off;
    set(gca, 'YLim',  get(handles.trace2, 'YLim'));
end

function SelectAllTraces(hObject, eventdata)

    handles = guidata(gcbf);
    SelectAll = handles.selectAllTraces.Value;
    traces = getappdata(gcbf, 'traces');
    
    Check = cell(1,length(traces));
    Check(:) = {logical(SelectAll)};
    Data = [Check;{traces.name}];
    
    set(handles.traces, 'Data', Data');

end

