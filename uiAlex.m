function uiAlex()
% create and open the main ALEX analysis ui
    
    fig = figure( ...
        'Units', 'pixel', ...
        'Position', [0, 0, 1000, 750], ...
        'Name', 'Trace Selection', ...
        'MenuBar', 'none', ...
        'Toolbar', 'none', ...
        'Color', get(0, 'defaultuicontrolbackgroundcolor'), ...
        'NumberTitle', 'off', ...
        'Resize', 'on', ...
        'Visible', 'off');
    
    % save all gui object handles as guidata so they can be accessed later
    handles = guidata(fig);
    
    % slice the display up into separate panels to organize the controls
    panelPhotonStreams = uipanel( ...
        'Parent', fig, ...
        'Units', 'normalized', ...
        'Position', [.01, .49, .79, .50], ...
        'Title', 'Photon Streams');
    panelMenu = uipanel( ...
        'Parent', fig, ...
        'Units', 'normalized', ...
        'Position', [.81, .49, .18, .50], ...
        'Title', 'Menu');
    panelTrace = uipanel( ...
        'Parent', fig, ...
        'Units', 'normalized', ...
        'Position', [.01, .01, .60, .47], ...
        'Title', 'Trace');
    panelTraces = uipanel( ...
        'Parent', fig, ...
        'Units', 'normalized', ...
        'Position', [.62, .01, .18, .47], ...
        'Title', 'Trace Selection');
    panelSettings = uipanel( ...
        'Parent', fig, ...
        'Units', 'normalized', ...
        'Position', [.81, .01, .18, .47], ...
        'Title', 'Calibration and Settings');
    
    % panelPhotonStreams: axes for all four photon streams
    handles.photonStreams = cell(4, 1);
    handles.photonStreams{1} = axes( ...
        'Parent', panelPhotonStreams, ...
        'Units', 'normalized', ...
        'OuterPosition', [.0, .0, .25, 1.0], ...
        'HandleVisibility', 'callback', ...
        'NextPlot', 'replacechildren');
    handles.photonStreams{2} = axes( ...
        'Parent', panelPhotonStreams, ...
        'Units', 'normalized', ...
        'OuterPosition', [.25, .0, .25, 1.0], ...
        'HandleVisibility', 'callback', ...
        'NextPlot', 'replacechildren');
    handles.photonStreams{3} = axes( ...
        'Parent', panelPhotonStreams, ...
        'Units', 'normalized', ...
        'OuterPosition', [.5, .0, .25, 1.0], ...
        'HandleVisibility', 'callback', ...
        'NextPlot', 'replacechildren');
    handles.photonStreams{4} = axes( ...
        'Parent', panelPhotonStreams, ...
        'Units', 'normalized', ...
        'OuterPosition', [.75, .0, .25, 1.0], ...
        'HandleVisibility', 'callback', ...
        'NextPlot', 'replacechildren');
    
    % panelMenu: buttons for all accessible actions
    uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'pushbutton', ...
        'Units', 'normalized', ...
        'Position', [.05, .9, .9, .1], ...
        'String', 'New Calibration', ...
        'Callback', @newCalibrationCallback, ...
        'BusyAction', 'cancel');
    uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'pushbutton', ...
        'Units', 'normalized', ...
        'Position', [.05, .8, .9, .1], ...
        'String', 'Load Calibration', ...
        'Callback', @loadCalibrationCallback, ...
        'BusyAction', 'cancel');
    handles.openMovie = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'pushbutton', ...
        'Units', 'normalized', ...
        'Position', [.05, .7, .9, .1], ...
        'String', 'Open Movie', ...
        'Callback', @openMovieCallback, ...
        'BusyAction', 'cancel');
    
    uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'text', ...
        'Units', 'normalized', ...
        'Position', [.05, .60, .9, .1], ...
        'String', 'Photon Streams Frame', ...
        'BusyAction', 'cancel');
    handles.photonStreamsStart = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'edit', ...
        'Units', 'normalized', ...
        'Position', [.05, .53, .2, .13], ...
        'String', '1', ...
        'BusyAction', 'cancel', ...
        'Callback', @updateSumPhotonStreams, ...
        'Enable', 'off');
    handles.photonStreamsEnd = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'edit', ...
        'Units', 'normalized', ...
        'Position', [.29, .53, .2, .13], ...
        'String', '10', ...
        'Callback', @updateSumPhotonStreams, ...
        'BusyAction', 'cancel', ...
        'Enable', 'off');    
    handles.photonStreamsMethod = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'popupmenu', ...
        'Units', 'normalized', ...
        'Position', [.53, .56, .42, .1], ...
        'String', strvcat('sum', 'max projection'), ...
        'Value', 1, ...
        'Callback', @updateSumPhotonStreams, ...
        'BusyAction', 'cancel', ...
        'Enable', 'off');
%     
    handles.photonStreamsNormalization = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'popupmenu', ...
        'Units', 'normalized', ...
        'Position', [.53, .49, .42, .1], ...
        'String', strvcat('relative', 'absolute'), ...
        'Value', 1, ...
        'Callback', @updateSumPhotonStreams, ...
        'BusyAction', 'cancel', ...
        'Enable', 'off');
    
    handles.extractTraces = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'pushbutton', ...
        'Units', 'normalized', ...
        'Position', [.05, .42, .9, .1], ...
        'String', 'Extract Traces', ...
        'Callback', @extractTracesCallback, ...
        'BusyAction', 'cancel', ...
        'Enable', 'off');
    handles.handpickTraces = uicontrol( ...
        'Parent' , panelMenu, ...
        'Style','pushbutton', ...
        'Units', 'normalized', ...
        'Position', [.05, .32, .9, .1], ...
        'String', 'Handpick Additional Traces', ...
        'Callback', @handpickTracesCallback, ...
        'BusyAction', 'cancel', ...
        'Enable', 'off');
    handles.exportTraces = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'pushbutton', ...
        'Units', 'normalized', ...
        'Position', [.05, .22, .9, .1], ...
        'String', 'Export Traces', ...
        'Callback', @exportTracesCallback, ...
        'BusyAction', 'cancel', ...
        'Enable', 'off');
    handles.calculateCorrections = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'pushbutton', ...
        'Units', 'normalized', ...
        'Position', [.05, .12, .9, .1], ...
        'String', 'Calculate Corrections', ...
        'Callback', @calculateCorrectionsCallback, ...
        'BusyAction','cancel', ...
        'Enable', 'off');
    handles.fretAnalysis = uicontrol( ...
        'Parent', panelMenu, ...
        'Style', 'pushbutton', ...
        'Units', 'normalized', ...
        'Position', [.05, .02, .9, .1], ...
        'String', 'Fret Analysis', ...
        'Callback', @fretAnalysisCallback, ...
        'BusyAction', 'cancel', ...
        'Enable', 'off');

    
    % panelTrace: axes for the selected trace
    handles.trace1 = axes( ...
        'Parent', panelTrace, ...
        'Units', 'normalized', ...
        'OuterPosition', [.0, .5, .75, .5], ...
        'HandleVisibility', 'callback', ...
        'NextPlot', 'replacechildren');
    handles.traceHist1 = axes( ...
        'Parent', panelTrace, ...
        'Units', 'normalized', ...
        'OuterPosition', [.75, .5, .25, .5], ...
        'HandleVisibility', 'callback', ...
        'NextPlot', 'replacechildren');
    handles.trace2 = axes( ...
        'Parent', panelTrace, ...
        'Units', 'normalized', ...
        'OuterPosition', [.0, .0, .75, .5], ...
        'HandleVisibility', 'callback', ...
        'NextPlot', 'replacechildren'); 
    handles.traceHist2 = axes( ...
        'Parent', panelTrace, ...
        'Units', 'normalized', ...
        'OuterPosition', [.75, .0, .25, .5], ...
        'HandleVisibility', 'callback', ...
        'NextPlot', 'replacechildren');
    
    % panelTraces: list of available traces with checkboxes for export
    handles.selectAllTraces = uicontrol( ...
        'Style', 'checkbox',...
        'Parent', panelTraces, ...
        'Units','normalized',...
        'Position', [.02, .95, .96, .04], ... 
        'String', 'Select All', ...
        'Callback', @SelectAllTraces, ...
        'Value', 1, ...
        'Enable', 'off');
    handles.traces = uitable( ...
        'Parent', panelTraces, ...
        'Units','normalized',...
        'Position', [.02, .01, .96, .93], ...
        'CellSelectionCallback', @tracesCallback, ...
        'ColumnFormat', {'logical','char'} ,...
        'ColumnEditable', [true,false],...
        'ColumnWidth', {15 141}, ...
        'ColumnName', [], ...
        'RowName', [], ...
        'Data', '' );
    
    % panelSettings: controls for calibration and alignment settings
    uicontrol( ...
        'Parent', panelSettings, ...
        'Style','text', ...
        'Units', 'normalized', ...
        'Position', [.02, .92, .96, .06], ...
        'String', 'Calibration File Path', ...
        'HorizontalAlignment', 'left');
    handles.calibrationFilePath = uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'edit', ...
        'Units', 'normalized', ...
        'Position', [.02, .86, .96, .06], ...
        'String', '', ...
        'UserData', '', ...
        'Callback', @calibrationFilePathCallback, ...
        'BusyAction', 'queue');
    uicontrol( ...
        'Parent', panelSettings, ...
        'Style','text', ...
        'Units', 'normalized', ...
        'Position', [.02, .78, .96, .06], ...
        'String', 'Slit Orientation', ...
        'HorizontalAlignment', 'left');
    handles.slitOrientation = uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'popupmenu', ...
        'Units', 'normalized', ...
        'Position', [.02, .72, .96, .07], ...
        'String', strvcat('horizontal', 'vertical'), ...
        'Value', 1, ...
        'Callback', @slitOrientationCallback, ...
        'BusyAction', 'cancel');
    uicontrol('Parent', panelSettings, ...
        'Style','text', ...
        'Units', 'normalized', ...
        'Position', [.02, .64, .96, .06], ...
        'String', 'Excitation Odd Images', ...
        'HorizontalAlignment', 'left');
    handles.excitationOdd = uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'popupmenu', ...
        'Units', 'normalized', ...
        'Position', [.02, .58, .96, .06], ...
        'String', strvcat('donor', 'acceptor'), ...
        'Value', 1, ...
        'Callback', @excitationOddCallback, ...
        'BusyAction', 'cancel');
    uicontrol('Parent', panelSettings, ...
        'Style','text', ...
        'Units', 'normalized', ...
        'Position', [.02, .50, .96, .06], ...
        'String', 'Detection Left Channel', ...
        'HorizontalAlignment', 'left');
    handles.detectionLeft = uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'popupmenu', ...
        'Units', 'normalized', ...
        'Position', [.02, .44, .96, .06], ...
        'String', strvcat('donor', 'acceptor'), ...
        'Value', 1, ...
        'Callback', @detectionLeftCallback, ...
        'BusyAction', 'cancel');
    uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'text', ...
        'String', 'Peak Radius', ...
        'Units', 'normalized', ...
        'Position', [.02, .36, .96, .06], ...
        'HorizontalAlignment', 'left');
    handles.peakRadius = uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'edit', ...
        'Units', 'normalized', ...
        'Position', [.02, .30, .96, .07], ...
        'String', num2str(3), ...
        'Callback', @peakRadiusCallback, ...
        'BusyAction', 'cancel');
    uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'text', ...
        'String', 'Trace Acquisition Method', ...
        'Units', 'normalized', ...
        'Position', [.02, .22, .96, .06], ...
        'HorizontalAlignment', 'left');
    handles.traceAcquisitionMethod = uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'popupmenu', ...
        'Units', 'normalized', ...
        'Position', [.02, .16, .96, .06], ...
        'String', strvcat('max', 'pixel', 'sum'), ...
        'Value', 3, ...
        'Callback', @traceAcquisitionMethodCallback, ...
        'BusyAction', 'cancel');
    uicontrol( ...
        'Parent', panelSettings, ...
        'Style', 'text', ...
        'String', 'Display Colormap', ...
        'Units','normalized', ...
        'Position', [.02, .08, .96, .06], ...
        'HorizontalAlignment', 'left');
    handles.colormap = uicontrol(...
        'Parent', panelSettings, ...
        'Style', 'popupmenu', ...
        'Units', 'normalized', ...
        'Position', [.02, .02, .96, .06], ...
        'String', strvcat('gray', 'hot', 'hsv', 'jet'), ...
        'Value', 2, ...
        'Callback', @colormapCallback, ...
        'BusyAction', 'cancel');
    
    % setting visibility to "on" only now speeds up the window creation
    set(fig, 'Visible', 'on');
    guidata(fig, handles);
    
    % use guidata only for handles related to the actual user interface
    % use appdata to store the actual data
    
    % use default values from the ui
    so = ui.readPopupmenu(handles.slitOrientation);
    eo = ui.readPopupmenu(handles.excitationOdd);
    dl = ui.readPopupmenu(handles.detectionLeft);
    % calibration for alex data w/o any transformations
    setappdata(fig, 'calibration', alex.movie.Calibration(2, 2, so));
    % default mapping between stream indices and names
    setappdata(fig, 'mapping', alex.movie.MappingAlex(eo, dl));
    % store empty placeholder variables for movie and list of traces
    setappdata(fig, 'movie', []);
    setappdata(fig, 'peaks', []);
    setappdata(fig, 'traces', []);
end

% -----------------------------------------------------------------------------
% calibration callbacks

function newCalibrationCallback(hObject, eventdata)
% call uiCalibration to create a new calibration file and load it
    
    [filePath, slitOrientation] = uiCalibration();
    
    % create a calibration object from the newly created transformation file
    % and the current ui settings
    
    if not(isempty(filePath))
        handles = guidata(hObject);
        
        if strcmpi(slitOrientation, 'horizontal')
            set(handles.slitOrientation, 'Value', 1);
        else
            set(handles.slitOrientation, 'Value', 2);
        end
        
        calibration = getappdata(gcbf, 'calibration');
        calibration.slitOrientation = slitOrientation;
        calibration.updateTransformationFromFile(filePath);
        set(handles.calibrationFilePath, 'String', calibration.filePath);
    end
end

function loadCalibrationCallback(hObject, eventdata)
% select a calibration file and load it
    
    filePath = ui.dialogOpenFile('.mat', 'Select a Calibration File');
    
    if not(isempty(filePath))
        handles = guidata(hObject);
        
        calibration = getappdata(gcbf, 'calibration');
        calibration.updateTransformationFromFile(filePath);
        set(handles.calibrationFilePath, 'String', calibration.filePath);
    end
end

function calibrationFilePathCallback(hObject, eventdata)
% restore the original value
%
% calibrationFile textedit must be enabled so that the whole path can be
% selected, but it should not be changed;
    
    calibration = getappdata(gcbf, 'calibration');
    set(hObject, 'String', calibration.filePath);
end

function slitOrientationCallback(hObject, eventdata)
% change slit orientation in the calibration
    
    calibration = getappdata(gcbf, 'calibration');
    calibration.slitOrientation = ui.readPopupmenu(hObject);
    
    movie = getappdata(gcbf, 'movie');
    if not(isempty(movie))
        
        movie.summarizePhotonStreams(1, 10, 'sum');
        
        % disable peak finding for photon stream w/ no expected peaks
        mapping = getappdata(gcbf, 'mapping');
        movie.peakThresholds(mapping.getIndex('AexDem')) = 255;
        movie.peakThresholds(mapping.getIndex('DexAem')) = 255;
        
        updatePhotonStreams();
        warning('changing the slit orientation does not affect traces')
    end
end

function excitationOddCallback(hObject, eventdata)
% change the excitation color alignment in the mapping and replot
    
    mapping = getappdata(gcbf, 'mapping');
    mapping.excitationOdd = ui.readPopupmenu(hObject);
    
    updatePhotonStreams();
    updateTrace();
end

function detectionLeftCallback(hObject, eventdata)
% change the detection color alignment in the mapping and replot
    
    mapping = getappdata(gcbf, 'mapping');
    mapping.detectionLeft = ui.readPopupmenu(hObject);
    
    updatePhotonStreams();
    updateTrace();
end

% -----------------------------------------------------------------------------
% movie callbacks

function openMovieCallback(hObject, eventdata)
% select a movie file and create the corresponding movie object
    
    [path_, filterIndex] = ui.dialogOpenFile({'*.tif';'*.sif'}, 'Select a Movie File');
    
    if not(isempty(path_))
        % allow different raw data formats, e.g. sif and tif
        if filterIndex == 2
            raw = alex.movie.SifFile(path_);
        elseif filterIndex == 1
            raw = alex.movie.TifFile(path_);
        end
        
        movie = alex.movie.Movie(raw, getappdata(gcbf, 'calibration'));
        
        % disable peak finding for photon stream w/ no expected peaks
        mapping = getappdata(gcbf, 'mapping');
        movie.peakThresholds(mapping.getIndex('AexDem')) = 255;
        movie.peakThresholds(mapping.getIndex('DexAem')) = 255;
        
        setappdata(gcbf, 'movie', movie);
        setappdata(gcbf, 'peaks', []);
        setappdata(gcbf, 'traces', []);
        
        handles = guidata(hObject);
        % update figure title
        set(gcbf, 'Name', ['Trace Selection (' movie.filePath ')']);
        % enable the newly accessible actions
        set(handles.photonStreamsStart, 'Enable', 'on');
        set(handles.photonStreamsEnd, 'Enable', 'on');
        set(handles.photonStreamsMethod, 'Enable', 'on');
        set(handles.photonStreamsNormalization, 'Enable', 'on');
        set(handles.extractTraces, 'Enable', 'on');
        set(handles.handpickTraces, 'Enable', 'on');
        % the following actions need extracted traces (not available now)
        set(handles.exportTraces, 'Enable', 'off');
        set(handles.calculateCorrections, 'Enable', 'off');
        set(handles.fretAnalysis, 'Enable', 'off');
        
        updatePhotonStreams();
        updateTraces();
        updateTrace();
    end
end

% -----------------------------------------------------------------------------
% peaks and traces callbacks

function extractTracesCallback(hObject, eventdata)
% select thresholds for the peak finder, run it and update the traces
    
    movie = getappdata(gcbf, 'movie');
    mapping = getappdata(gcbf, 'mapping');
    handles = guidata(hObject);
    
    uiThresholds(movie, mapping);
    movie.peakRadius = str2num(get(handles.peakRadius, 'String'));
    movie.traceAquisitionMethod = ui.readPopupmenu(handles.traceAcquisitionMethod);
    
    [peaks, peaksPhotonStream] = alex.movie.findPeaks(movie);
    setappdata(gcbf, 'peaks', peaks);
    setappdata(gcbf, 'peaksPhotonStream', peaksPhotonStream);
    updatePhotonStreams();
    
    traces = alex.traces.extract(movie, mapping, peaks);
    setappdata(gcbf, 'traces', traces);
    updateTraces();
    updateTrace();
    
    % enable the actions that are now accessible with existing traces
    % TODO only enable if there are some resulting traces
    set(handles.exportTraces, 'Enable', 'on');
    set(handles.selectAllTraces, 'Enable', 'on');
    set(handles.calculateCorrections, 'Enable', 'on');
    set(handles.fretAnalysis, 'Enable', 'on');
end

function handpickTracesCallback(hObject, eventdata)
% select points in the axes by left mouseclick,
% end selection by pressing the return button
    
    movie = getappdata(gcbf, 'movie');
    mapping = getappdata(gcbf, 'mapping');
    peaks = getappdata(gcbf, 'peaks');
    peaksPhotonStream = getappdata(gcbf, 'peaksInPhotonStream');
    handles = guidata(hObject);
    
    movie.peakRadius = str2num(get(handles.peakRadius, 'String'));
    movie.traceAquisitionMethod = ui.readPopupmenu(handles.traceAcquisitionMethod);
    
    
    [peaks, peaksPhotonStream] = alex.movie.handpickPeaks(movie, mapping, peaks, peaksPhotonStream, handles);
    setappdata(gcbf, 'peaks', peaks);
    setappdata(gcbf, 'peaksPhotonStream', peaksPhotonStream);
    updatePhotonStreams();

    traces = alex.traces.extract(movie, mapping, peaks);
    setappdata(gcbf, 'traces', traces);
    updateTraces();
    updateTrace();
    
    % enable the actions that are now accessible with existing traces
    % TODO only enable if there are some resulting traces
    set(handles.exportTraces, 'Enable', 'on');
    set(handles.selectAllTraces, 'Enable', 'on');
%     set(handles.calculateCorrections, 'Enable', 'on');
%     set(handles.fretAnalysis, 'Enable', 'on');
end


function exportTracesCallback(hObject, eventdata)
% select a file name and export the currently selected traces to it
    
    handles = guidata(hObject);
    selected = find(cell2mat(handles.traces.Data(:,1)));
    
    movie = getappdata(gcbf, 'movie');
    mapping = getappdata(gcbf, 'mapping');
    traces = getappdata(gcbf, 'traces');
    
    % suggest a export file based on the movie file path
    exportFileSuggestion = strcat(movie.filePath(1:end-3), 'csv');
    [fileName, pathName] = ...
        uiputfile('.csv', 'Select an Export File', exportFileSuggestion);
    
    if not(fileName == 0) % user canceled operation
        file_ = fullfile(pathName, fileName);
        
        % comment/uncomment the wanted exports
        % WARNING need to comment/uncomment the corresponding section in the
        % fret analysis callback
        
        % STANDARD EXPORT WITH FULL INFORMATION
        alex.exportCsv(file_, movie, mapping, traces(selected));
    end
end

function tracesCallback(hObject, callbackdata)
% update the trace plot to show the newly selected trace
    
    updateTrace(hObject, callbackdata);
end

function peakRadiusCallback(hObject, eventdata)
% recalculate the traces with the new peak radius
    
    movie = getappdata(gcbf, 'movie');
    movie.peakRadius = str2num(get(hObject, 'String'));
    
    traces = alex.traces.extract(movie, getappdata(gcbf, 'peaks'));
    setappdata(gcbf, 'traces', traces);
    
    updatePhotonStreams();
    updateTraces();
    updateTrace();
end

function traceAcquisitionMethodCallback(hObject, eventdata)
% recalculate traces with the new aquisition method
    
    movie = getappdata(gcbf, 'movie');
    mapping = getappdata(gcbf, 'mapping');
    movie.traceAquisitionMethod = ui.readPopupmenu(hObject);
    
    traces = alex.traces.extract(movie, mapping, getappdata(gcbf, 'peaks'));
    setappdata(gcbf, 'traces', traces);
    
    updatePhotonStreams();
    updateTraces();
    updateTrace();
end

% -----------------------------------------------------------------------------
% further analysis callbacks

function calculateCorrectionsCallback(hObject, eventdata)
% call calculate correction factors with the currently selected traces
    handles = guidata(hObject);
    selected = find(cell2mat(handles.traces.Data(:,1)))
    
    movie = getappdata(gcbf, 'movie');
    traces = getappdata(gcbf, 'traces');
    
    % NO EXTRA FILTER
    uiCalculateCorrections(movie, traces(selected));
end

function fretAnalysisCallback(hObject, eventdata)
% call fret analysis with the currently selected traces
    
    handles = guidata(hObject);
    selected = find(cell2mat(handles.traces.Data(:,1)));
    
    movie = getappdata(gcbf, 'movie');
    mapping = getappdata(gcbf, 'mapping');
    traces = getappdata(gcbf, 'traces');
    peaksPhotonStream = getappdata(gcbf, 'peaksPhotonStream');
    
    % uncomment the wanted filter
    % WARNING need to comment/uncomment the corresponding section in the export
    % function
    
    % FILTER FOR TF DETECTION (remove red only traces)
%     selectedTraces = alex.traces.filterTf(traces(selected));
%     selectedFrames = alex.traces.detectBleachingOutliersTf(selectedTraces);
%     uiFretAnalysis(movie, mapping, selectedTraces, peaksPhotonStream, selectedFrames);
    % BLEACHING DETECTION
%     selectedTraces = traces(selected);
%     selectedFrames = alex.traces.detectBleachingOutliersTf(selectedTraces);
%     uiFretAnalysis(movie, mapping, selectedTraces, selectedFrames);
    % NO EXTRA FILTER
    selectedTraces = traces(selected);
    uiFretAnalysis(movie, mapping,  selectedTraces, peaksPhotonStream(:, selected));
    % FOR JESSICA (select only the first two frames)
%     selectedTraces = traces(selected);
%     selectedFrames = cell(length(selectedTraces), 1);
%     for i = 1:length(selectedFrames)
%         selectedFrames{i} = 1:1;
%     end
%     uiFretAnalysis(movie, mapping, selectedTraces, peaksPhotonStream, selectedFrames);
end

% -----------------------------------------------------------------------------
% misc callbacks

function updateSumPhotonStreams(hObject, eventdata)
% replot the photon streams with the new start and end frame
    handles = guidata(gcbf);
    movie = getappdata(gcbf, 'movie');
    
    % recover the start and end frame from the gui
    startFrame = str2num(get(handles.photonStreamsStart, 'String'));
    endFrame = str2num(get(handles.photonStreamsEnd, 'String'));
    
    % recover wether sum or max projection should be used for photon stream
    % image
    method = ui.readPopupmenu(handles.photonStreamsMethod);
    normalization = ui.readPopupmenu(handles.photonStreamsNormalization);
    movie.summarizePhotonStreams(startFrame, endFrame - startFrame + 1, method, normalization);
    updatePhotonStreams();
end

function colormapCallback(hObject, eventdata)
% replot the photon streams with the new colormap
    
    updatePhotonStreams();
end

% -----------------------------------------------------------------------------
% update plotted data

function updatePhotonStreams()
% plot the photon stream sum images
    
    movie = getappdata(gcbf, 'movie');
    mapping = getappdata(gcbf, 'mapping');
    peaks = getappdata(gcbf, 'peaks');
    
    handles = guidata(gcbf);
    cm = ui.readPopupmenu(handles.colormap);
    axs = handles.photonStreams;
    
    % plot the photon streams
    images = alex.movie.createPhotonStreamImages(movie, peaks, cm);
    for i = 1:length(images)
        namePhotonStream = mapping.names{i};
        
        axes(axs{i});
        hold off;
        image(images{mapping.getIndex(namePhotonStream)});
        title(namePhotonStream);
        grid on;
        hold on;
    end
end

function updateTraces(hObject, eventdata)
% update the list of traces
    
    traces = getappdata(gcbf, 'traces');
    
    handles = guidata(gcbf);
    
    if not(isempty(traces))
        % remove old selection and update traces
        % set(handles.traces, 'Value', [1])
        Check = num2cell(true(1,length(traces)));
        Data = [Check;{traces.name}];
        set(handles.traces, 'Data', Data');
    else
        set(handles.traces, 'Data', '');
    end
end

function updateTrace(varargin)
% display the currently selected trace (if any exists)
    
    traces = getappdata(gcbf, 'traces');
    if nargin == 0; return; end
    if isempty(varargin{2}.Indices); return; end
    
    handles = guidata(gcbf);
    % listbox allows multiple selection; plot the first trace in selection
    indices = varargin{2}.Indices;
    t = traces(indices(1));
    
    ui.plotTraceIntensities(t, handles.trace1, handles.trace2);
    
    axes(handles.traceHist1);
    % create histogram of both excitation channels and background channels
    photonCountsRedExRedEm = t.rawByName('AexAem');
    [n, xout] = hist(photonCountsRedExRedEm, 30);
    barh(xout, n, 'FaceColor', [1,0,0], 'EdgeColor', [1,0,0]);
    hold on;
    photonCountsGreenExRedEm = t.rawByName('DexAem');
    [n, xout] = hist(photonCountsGreenExRedEm, 30);
    barh(xout, n, 'FaceColor', [0,1,0], 'EdgeColor', [0,1,0]);
    hold on;
    photonCountsRedExRedEmBkg = t.backgroundByName('AexAem');
    [n, xout] = hist(photonCountsRedExRedEmBkg, 30);
    barh(xout, n, 'FaceColor', [0.5,0,0], 'EdgeColor', [0.5,0,0]);
    hold on;
    photonCountsGreenExRedEmBkg = t.backgroundByName('DexAem');
    [n, xout] = hist(photonCountsGreenExRedEmBkg, 30);
    barh(xout, n, 'FaceColor', [0,0.5,0], 'EdgeColor', [0,0.5,0]);
    hold off;
    set(gca, 'YLim',  get(handles.trace1, 'YLim'));
    
    axes(handles.traceHist2);
    % create histogram of both excitation channels and background channels
    photonCountsRedExGreenEm = t.rawByName('AexDem');
    [n, xout] = hist(photonCountsRedExGreenEm, 30);
    barh(xout, n, 'FaceColor', [1,0,0], 'EdgeColor', [1,0,0]);
    hold on;
    photonCountsGreenExGreenEm = t.rawByName('DexDem');
    [n, xout] = hist(photonCountsGreenExGreenEm, 30);
    barh(xout, n, 'FaceColor', [0,1,0], 'EdgeColor', [0,1,0]);
    hold on;
    photonCountsRedExGreenEmBkg = t.backgroundByName('AexDem');
    [n, xout] = hist(photonCountsRedExGreenEmBkg, 30);
    barh(xout, n, 'FaceColor', [0.5,0,0], 'EdgeColor', [0.5,0,0]);
    hold on;
    photonCountsGreenExGreenEmBkg = t.backgroundByName('DexDem');
    [n, xout] = hist(photonCountsGreenExGreenEmBkg, 30);
    barh(xout, n, 'FaceColor', [0,0.5,0], 'EdgeColor', [0,0.5,0]);
    hold off;
    set(gca, 'YLim',  get(handles.trace2, 'YLim'));
end

function SelectAllTraces(hObject, eventdata)

    handles = guidata(gcbf);
    SelectAll = handles.selectAllTraces.Value;
    traces = getappdata(gcbf, 'traces');
    
    Check = cell(1,length(traces));
    Check(:) = {logical(SelectAll)};
    Data = [Check;{traces.name}];
    
    set(handles.traces, 'Data', Data');

end

